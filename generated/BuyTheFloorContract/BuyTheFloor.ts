// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class BuyTheFloorEvent extends ethereum.Event {
  get params(): BuyTheFloor__Params {
    return new BuyTheFloor__Params(this);
  }
}

export class BuyTheFloor__Params {
  _event: BuyTheFloorEvent;

  constructor(event: BuyTheFloorEvent) {
    this._event = event;
  }

  get bidderAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get sellerAddress(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get nftContractAddress(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get currencyTokenAddress(): Address {
    return this._event.parameters[4].value.toAddress();
  }

  get currencyTokenAmount(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get _from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _to(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class SignatureBurnedEvent extends ethereum.Event {
  get params(): SignatureBurned__Params {
    return new SignatureBurned__Params(this);
  }
}

export class SignatureBurned__Params {
  _event: SignatureBurnedEvent;

  constructor(event: SignatureBurnedEvent) {
    this._event = event;
  }

  get bidderAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get hash(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }
}

export class BuyTheFloor extends ethereum.SmartContract {
  static bind(address: Address): BuyTheFloor {
    return new BuyTheFloor("BuyTheFloor", address);
  }

  _chain_id(): BigInt {
    let result = super.call("_chain_id", "_chain_id():(uint256)", []);

    return result[0].toBigInt();
  }

  try__chain_id(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("_chain_id", "_chain_id():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  _fee_pct(): BigInt {
    let result = super.call("_fee_pct", "_fee_pct():(uint256)", []);

    return result[0].toBigInt();
  }

  try__fee_pct(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("_fee_pct", "_fee_pct():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  burnedSignatures(param0: Bytes): BigInt {
    let result = super.call(
      "burnedSignatures",
      "burnedSignatures(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return result[0].toBigInt();
  }

  try_burnedSignatures(param0: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "burnedSignatures",
      "burnedSignatures(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  cancelBid(
    nftContractAddress: Address,
    to: Address,
    currencyToken: Address,
    currencyAmount: BigInt,
    expires: BigInt,
    buyerSignature: Bytes
  ): boolean {
    let result = super.call(
      "cancelBid",
      "cancelBid(address,address,address,uint256,uint256,bytes):(bool)",
      [
        ethereum.Value.fromAddress(nftContractAddress),
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromAddress(currencyToken),
        ethereum.Value.fromUnsignedBigInt(currencyAmount),
        ethereum.Value.fromUnsignedBigInt(expires),
        ethereum.Value.fromBytes(buyerSignature)
      ]
    );

    return result[0].toBoolean();
  }

  try_cancelBid(
    nftContractAddress: Address,
    to: Address,
    currencyToken: Address,
    currencyAmount: BigInt,
    expires: BigInt,
    buyerSignature: Bytes
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "cancelBid",
      "cancelBid(address,address,address,uint256,uint256,bytes):(bool)",
      [
        ethereum.Value.fromAddress(nftContractAddress),
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromAddress(currencyToken),
        ethereum.Value.fromUnsignedBigInt(currencyAmount),
        ethereum.Value.fromUnsignedBigInt(expires),
        ethereum.Value.fromBytes(buyerSignature)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getBidDomainTypehash(): Bytes {
    let result = super.call(
      "getBidDomainTypehash",
      "getBidDomainTypehash():(bytes32)",
      []
    );

    return result[0].toBytes();
  }

  try_getBidDomainTypehash(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getBidDomainTypehash",
      "getBidDomainTypehash():(bytes32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getBidPacketHash(
    bidderAddress: Address,
    nftContractAddress: Address,
    currencyTokenAddress: Address,
    currencyTokenAmount: BigInt,
    expires: BigInt
  ): Bytes {
    let result = super.call(
      "getBidPacketHash",
      "getBidPacketHash(address,address,address,uint256,uint256):(bytes32)",
      [
        ethereum.Value.fromAddress(bidderAddress),
        ethereum.Value.fromAddress(nftContractAddress),
        ethereum.Value.fromAddress(currencyTokenAddress),
        ethereum.Value.fromUnsignedBigInt(currencyTokenAmount),
        ethereum.Value.fromUnsignedBigInt(expires)
      ]
    );

    return result[0].toBytes();
  }

  try_getBidPacketHash(
    bidderAddress: Address,
    nftContractAddress: Address,
    currencyTokenAddress: Address,
    currencyTokenAmount: BigInt,
    expires: BigInt
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getBidPacketHash",
      "getBidPacketHash(address,address,address,uint256,uint256):(bytes32)",
      [
        ethereum.Value.fromAddress(bidderAddress),
        ethereum.Value.fromAddress(nftContractAddress),
        ethereum.Value.fromAddress(currencyTokenAddress),
        ethereum.Value.fromUnsignedBigInt(currencyTokenAmount),
        ethereum.Value.fromUnsignedBigInt(expires)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getBidPacketTypehash(): Bytes {
    let result = super.call(
      "getBidPacketTypehash",
      "getBidPacketTypehash():(bytes32)",
      []
    );

    return result[0].toBytes();
  }

  try_getBidPacketTypehash(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getBidPacketTypehash",
      "getBidPacketTypehash():(bytes32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getBidTypedDataHash(
    bidderAddress: Address,
    nftContractAddress: Address,
    currencyTokenAddress: Address,
    currencyTokenAmount: BigInt,
    expires: BigInt
  ): Bytes {
    let result = super.call(
      "getBidTypedDataHash",
      "getBidTypedDataHash(address,address,address,uint256,uint256):(bytes32)",
      [
        ethereum.Value.fromAddress(bidderAddress),
        ethereum.Value.fromAddress(nftContractAddress),
        ethereum.Value.fromAddress(currencyTokenAddress),
        ethereum.Value.fromUnsignedBigInt(currencyTokenAmount),
        ethereum.Value.fromUnsignedBigInt(expires)
      ]
    );

    return result[0].toBytes();
  }

  try_getBidTypedDataHash(
    bidderAddress: Address,
    nftContractAddress: Address,
    currencyTokenAddress: Address,
    currencyTokenAmount: BigInt,
    expires: BigInt
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getBidTypedDataHash",
      "getBidTypedDataHash(address,address,address,uint256,uint256):(bytes32)",
      [
        ethereum.Value.fromAddress(bidderAddress),
        ethereum.Value.fromAddress(nftContractAddress),
        ethereum.Value.fromAddress(currencyTokenAddress),
        ethereum.Value.fromUnsignedBigInt(currencyTokenAmount),
        ethereum.Value.fromUnsignedBigInt(expires)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getEIP712DomainHash(
    contractName: string,
    version: string,
    chainId: BigInt,
    verifyingContract: Address
  ): Bytes {
    let result = super.call(
      "getEIP712DomainHash",
      "getEIP712DomainHash(string,string,uint256,address):(bytes32)",
      [
        ethereum.Value.fromString(contractName),
        ethereum.Value.fromString(version),
        ethereum.Value.fromUnsignedBigInt(chainId),
        ethereum.Value.fromAddress(verifyingContract)
      ]
    );

    return result[0].toBytes();
  }

  try_getEIP712DomainHash(
    contractName: string,
    version: string,
    chainId: BigInt,
    verifyingContract: Address
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getEIP712DomainHash",
      "getEIP712DomainHash(string,string,uint256,address):(bytes32)",
      [
        ethereum.Value.fromString(contractName),
        ethereum.Value.fromString(version),
        ethereum.Value.fromUnsignedBigInt(chainId),
        ethereum.Value.fromAddress(verifyingContract)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  newOwner(): Address {
    let result = super.call("newOwner", "newOwner():(address)", []);

    return result[0].toAddress();
  }

  try_newOwner(): ethereum.CallResult<Address> {
    let result = super.tryCall("newOwner", "newOwner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  sellNFT(
    nftContractAddress: Address,
    tokenId: BigInt,
    from: Address,
    to: Address,
    currencyToken: Address,
    currencyAmount: BigInt,
    expires: BigInt,
    buyerSignature: Bytes
  ): boolean {
    let result = super.call(
      "sellNFT",
      "sellNFT(address,uint256,address,address,address,uint256,uint256,bytes):(bool)",
      [
        ethereum.Value.fromAddress(nftContractAddress),
        ethereum.Value.fromUnsignedBigInt(tokenId),
        ethereum.Value.fromAddress(from),
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromAddress(currencyToken),
        ethereum.Value.fromUnsignedBigInt(currencyAmount),
        ethereum.Value.fromUnsignedBigInt(expires),
        ethereum.Value.fromBytes(buyerSignature)
      ]
    );

    return result[0].toBoolean();
  }

  try_sellNFT(
    nftContractAddress: Address,
    tokenId: BigInt,
    from: Address,
    to: Address,
    currencyToken: Address,
    currencyAmount: BigInt,
    expires: BigInt,
    buyerSignature: Bytes
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "sellNFT",
      "sellNFT(address,uint256,address,address,address,uint256,uint256,bytes):(bool)",
      [
        ethereum.Value.fromAddress(nftContractAddress),
        ethereum.Value.fromUnsignedBigInt(tokenId),
        ethereum.Value.fromAddress(from),
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromAddress(currencyToken),
        ethereum.Value.fromUnsignedBigInt(currencyAmount),
        ethereum.Value.fromUnsignedBigInt(expires),
        ethereum.Value.fromBytes(buyerSignature)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get chainId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get fee_pct(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class DefaultCall extends ethereum.Call {
  get inputs(): DefaultCall__Inputs {
    return new DefaultCall__Inputs(this);
  }

  get outputs(): DefaultCall__Outputs {
    return new DefaultCall__Outputs(this);
  }
}

export class DefaultCall__Inputs {
  _call: DefaultCall;

  constructor(call: DefaultCall) {
    this._call = call;
  }
}

export class DefaultCall__Outputs {
  _call: DefaultCall;

  constructor(call: DefaultCall) {
    this._call = call;
  }
}

export class AcceptOwnershipCall extends ethereum.Call {
  get inputs(): AcceptOwnershipCall__Inputs {
    return new AcceptOwnershipCall__Inputs(this);
  }

  get outputs(): AcceptOwnershipCall__Outputs {
    return new AcceptOwnershipCall__Outputs(this);
  }
}

export class AcceptOwnershipCall__Inputs {
  _call: AcceptOwnershipCall;

  constructor(call: AcceptOwnershipCall) {
    this._call = call;
  }
}

export class AcceptOwnershipCall__Outputs {
  _call: AcceptOwnershipCall;

  constructor(call: AcceptOwnershipCall) {
    this._call = call;
  }
}

export class CancelBidCall extends ethereum.Call {
  get inputs(): CancelBidCall__Inputs {
    return new CancelBidCall__Inputs(this);
  }

  get outputs(): CancelBidCall__Outputs {
    return new CancelBidCall__Outputs(this);
  }
}

export class CancelBidCall__Inputs {
  _call: CancelBidCall;

  constructor(call: CancelBidCall) {
    this._call = call;
  }

  get nftContractAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get currencyToken(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get currencyAmount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get expires(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get buyerSignature(): Bytes {
    return this._call.inputValues[5].value.toBytes();
  }
}

export class CancelBidCall__Outputs {
  _call: CancelBidCall;

  constructor(call: CancelBidCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class SellNFTCall extends ethereum.Call {
  get inputs(): SellNFTCall__Inputs {
    return new SellNFTCall__Inputs(this);
  }

  get outputs(): SellNFTCall__Outputs {
    return new SellNFTCall__Outputs(this);
  }
}

export class SellNFTCall__Inputs {
  _call: SellNFTCall;

  constructor(call: SellNFTCall) {
    this._call = call;
  }

  get nftContractAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get from(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get currencyToken(): Address {
    return this._call.inputValues[4].value.toAddress();
  }

  get currencyAmount(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }

  get expires(): BigInt {
    return this._call.inputValues[6].value.toBigInt();
  }

  get buyerSignature(): Bytes {
    return this._call.inputValues[7].value.toBytes();
  }
}

export class SellNFTCall__Outputs {
  _call: SellNFTCall;

  constructor(call: SellNFTCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get _newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}
